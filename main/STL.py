import numpy as np
import struct

TEXT_ENCODING = 'txt'
BINARY_ENCODING = 'bin'
VALID_ENCODINGS = [ TEXT_ENCODING, BINARY_ENCODING ]


class STLFacet:
    """a single polygon facet that knows how to encode itself when asked"""

    def __init__(self, pt1, pt2, pt3):
        # Calculate the normal for this facet
        self.p1 = np.array([pt1[0], pt1[1], pt1[2]])
        self.p2 = np.array([pt2[0], pt2[1], pt2[2]])
        self.p3 = np.array([pt3[0], pt3[1], pt3[2]])

        # These two vectors are in the plane
        v1 = self.p3 - self.p1
        v2 = self.p2 - self.p1

        # the cross product is a vector normal to the plane
        cp = np.cross(v1, v2)
        self.normal_a, self.normal_b, self.normal_c = cp

    def get_text_encoding(self) -> list:
        """ Get the text encoding of this facet's points, ready to write in order

        :return: list of strings encoding each point as an ASCII string
        """
        # TODO further refactor to bring strings up to standard usage

        list_pts = [
            # normal, a, b, c
            "facet normal " + "%E" % self.normal_a + " " + "%E" % self.normal_b + " " + "%E" % self.normal_c + "\n",
            "\touter loop\n",
            # first corner points 0,1,2
            "\t\tvertex " + "%E" % self.p1[0] + " " + "%E" % self.p1[1] + " " + "%E" % self.p1[2] + "\n",
            # second corner points 0,1,2
            "\t\tvertex " + "%E" % self.p2[0] + " " + "%E" % self.p2[1] + " " + "%E" % self.p2[2] + "\n",
            # third corner points 0,1,2
            "\t\tvertex " + "%E" % self.p3[0] + " " + "%E" % self.p3[1] + " " + "%E" % self.p3[2] + "\n",
            "\tendloop\n",
            "endfacet\n"
        ]

        return list_pts

    def get_binary_encoding(self) -> list:
        """ Get the binary encoding of this facet's points, in write ofder
        :return: list of byte's representing binary encoding of each vertext point

        Points are written in IEEE 32-bit floating point
        """
        # I used the info here to figure out how to write these IEEE 32bit floating point numbers
        # from https://www.linuxquestions.org/questions/programming-9/write-a-file-fo-data-array-with-float-values-in-a-binary-format-in-python-937020/

        list_pts = [
            # the normal and each of the vertexes in IEEE floating point numbers
                struct.pack('<%df' % 3, *[self.normal_a, self.normal_b, self.normal_c]),
            # each of the three points in IEEE floating point numbers
                    struct.pack('<%df' % 3, *[self.p1[0], self.p1[1], self.p1[2]]),
                    struct.pack('<%df' % 3, *[self.p2[0], self.p2[1], self.p2[2]]),
                    struct.pack('<%df' % 3, *[self.p3[0], self.p3[1], self.p3[2]]),
            # 8 bytes as an attribute thing. Copies these (int 115 and int 73  from a file generated by Fusion 360.
                    int(115).to_bytes(1, byteorder="little", signed=False),
                    int(78).to_bytes(1, byteorder="little", signed=False)
        ]
        return list_pts


class STLFile:
    """Using the 'resource manager' pattern, this class provides the standard methods
        for use in a 'with' statement. As such, it opens the STL output file, and
        keeps the file open until the calling scope exits.
    """

    def __init__(self, filepath, filetype, num_facets, solid_name=None):
        """Initialize all resource parameters"""
        self.file_path = filepath
        assert(filetype in VALID_ENCODINGS)
        self.file_type = filetype
        self.num_facets = num_facets
        self.solid_name = solid_name if solid_name else ""
        self.file_obj = None

    def __enter__(self):
        """invoked by the 'with' statement, returns object for appending to"""
        if self.file_type == TEXT_ENCODING:
            self.file_obj = open(self.file_path, 'w')
            self.file_obj.write(f'solid {self.solid_name}\n')
        elif self.file_type == BINARY_ENCODING:
            self.file_obj = open(self.file_path, 'wb')

            # TODO create this  string programmatically
            # create and write an 80 character header - any characters will do
            header = bytearray("STL Builder output          3         4         5         6         7         80",
                               'utf8')
            self.file_obj.write(header)

            # write a 4-byte little-endian unsigned integer indicating the number of facets
            self.file_obj.write(self.num_facets.to_bytes(4, byteorder="little", signed=False))
        else:
            raise Exception(f'unknown file type {self.file_type}')

        return self

    def __exit__(self, exception_type, exception_value, traceback):
        """invoked when 'with' statement goes out of scope, properly terminates file."""
        if self.file_type == 'txt':
            self.file_obj.write(f'endsolid {self.solid_name}\n' )

        if self.file_obj:
            self.file_obj.close()

    def append_facet(self, facet: STLFacet):
        """Use this to write a facet to this STL resource"""
        if self.file_type == TEXT_ENCODING:
            data_list = facet.get_text_encoding()
        elif self.file_type == BINARY_ENCODING:
            data_list = facet.get_binary_encoding()
        else:
            raise Exception(f'unknown file_type {self.file_type}')

        for datum in data_list:
                self.file_obj.write(datum)

        return self

